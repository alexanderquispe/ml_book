# Analyzing RCT with Precision by Adjusting for Baseline Covariates

## Jonathan Roth's DGP

Here we set up a DGP with heterogenous effects. In this example, with is due to Jonathan Roth, we have
$$E [Y(0) | Z] = - Z, \quad E [Y(1) |Z] = Z, \quad Z \sim N(0,1)$$
The CATE is
$$E [Y(1) - Y(0) | Z ]= 2 Z$$
and the ATE is
$$ 2 E Z = 0$$

We would like to estimate ATE as precisely as possible.

An economic motivation for this example could be provided as follows: Let D be the treatment of going to college, and $Z$ academic skills.  Suppose that academic skills cause lower earnings $Y(0)$ in jobs that don't require college degree, and cause higher earnings  $Y(1)$ in jobs that require college degrees. This type of scenario is reflected in the DGP set-up above.

:::::: {.columns}
::: {.column width="49.5%" data-latex="{0.48\textwidth}"}
**R code**
```{r}
# No libraries needed.
```

:::
::: {.column width="1%" data-latex="{0.04\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::
:::::: {.column width="49.5%" data-latex="{0.48\textwidth}"}

**Python code**

```{python}
# Import relevant packages for splitting data
import numpy as np
import random
import math
import pandas as pd
```

:::
::::::

:::::: {.columns}
::: {.column width="49.5%" data-latex="{0.48\textwidth}"}

```{r}
set.seed(123)        # set MC seed
n = 1000             # sample size
Z = rnorm(n)         # generate Z
Y0 = -Z + rnorm(n)   # conditional average baseline response is -Z
Y1 = Z + rnorm(n)    # conditional average treatment effect is +Z
D = (runif(n)<.2)    # treatment indicator; only 20% get treated 
mean(D)
```

:::
::: {.column width="1%" data-latex="{0.04\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::
:::::: {.column width="49.5%" data-latex="{0.48\textwidth}"}


```{python}
np.random.seed(12345676)     # set MC seed
n = 1000                     # sample size
Z = np.random.normal(0, 1, 1000).reshape((1000, 1))  # generate Z
Y0 = -Z + np.random.normal(0, 1, 1000).reshape((1000, 1))   # conditional average baseline response is -Z
Y1 = Z + np.random.normal(0, 1, 1000).reshape((1000, 1))    # conditional average treatment effect is +Z
D = (np.random.uniform(0, 1, n)<.2).reshape((1000, 1))      # treatment indicator; only 20% get treated
np.mean(D)
```

:::
::::::


:::::: {.columns}
::: {.column width="49.5%" data-latex="{0.48\textwidth}"}

```{r}
Y = Y1*D + Y0*(1-D)  # observed Y
D = D - mean(D)      # demean D
Z = Z-mean(Z)        # demean Z
```

:::
::: {.column width="1%" data-latex="{0.04\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::
:::::: {.column width="49.5%" data-latex="{0.48\textwidth}"}


```{python}
Y = Y1*D + Y0*(1-D)  # observed Y
D = D - np.mean(D)      # demean D
Z = Z - np.mean(Z)        # demean Z
```

:::
::::::

# Analyze the RCT data with Precision Adjustment

Consider 

*  classical 2-sample approach, no adjustment (CL)
*  classical linear regression adjustment (CRA)
*  interactive regression adjusment (IRA)

Carry out inference using robust inference, using the sandwich formulas (Eicker-Huber-White).  

Observe that CRA delivers estimates that are less efficient than CL (pointed out by Freedman), whereas IRA delivers more efficient approach (pointed out by Lin). In order for CRA to be more efficient than CL, we need the CRA to be a correct model of the conditional expectation function of Y given D and X, which is not the case here.

:::::: {.columns}
::: {.column width="49.5%" data-latex="{0.48\textwidth}"}

```{r}
library(lmtest)
CL = lm(Y ~ D)          
CRA = lm(Y ~ D+ Z)      #classical
IRA = lm(Y ~ D+ Z+ Z*D) #interactive approach
# we are interested in the coefficients on variable "D".
library(sandwich)
library(lmtest)
coeftest(CL, vcov = vcovHC(CL, type="HC1"))
coeftest(CRA, vcov = vcovHC(CRA, type="HC1"))
coeftest(IRA, vcov = vcovHC(IRA, type="HC1"))
```

:::
::: {.column width="1%" data-latex="{0.04\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::
:::::: {.column width="49.5%" data-latex="{0.48\textwidth}"}


```{python}
Z_times_D = Z*D
X = np.hstack((D, Z, Z_times_D))
data = pd.DataFrame(X, columns = ["D", "Z", "Z_times_D"])
```

:::
::::::
