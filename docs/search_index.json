[["analyzing-rct-with-precision-by-adjusting-for-baseline-covariates.html", "Chapter 5 Analyzing RCT with Precision by Adjusting for Baseline Covariates 5.1 Jonathan Roths DGP", " Chapter 5 Analyzing RCT with Precision by Adjusting for Baseline Covariates 5.1 Jonathan Roths DGP Here we set up a DGP with heterogenous effects. In this example, with is due to Jonathan Roth, we have \\[E [Y(0) | Z] = - Z, \\quad E [Y(1) |Z] = Z, \\quad Z \\sim N(0,1)\\] The CATE is \\[E [Y(1) - Y(0) | Z ]= 2 Z\\] and the ATE is \\[ 2 E Z = 0\\] We would like to estimate ATE as precisely as possible. An economic motivation for this example could be provided as follows: Let D be the treatment of going to college, and \\(Z\\) academic skills. Suppose that academic skills cause lower earnings \\(Y(0)\\) in jobs that dont require college degree, and cause higher earnings \\(Y(1)\\) in jobs that require college degrees. This type of scenario is reflected in the DGP set-up above. R code # No libraries needed.   Python code # Import relevant packages for splitting data import numpy as np import random import math import pandas as pd set.seed(123) # set MC seed n = 1000 # sample size Z = rnorm(n) # generate Z Y0 = -Z + rnorm(n) # conditional average baseline response is -Z Y1 = Z + rnorm(n) # conditional average treatment effect is +Z D = (runif(n)&lt;.2) # treatment indicator; only 20% get treated mean(D) ## [1] 0.186   np.random.seed(12345676) # set MC seed n = 1000 # sample size Z = np.random.normal(0, 1, 1000).reshape((1000, 1)) # generate Z Y0 = -Z + np.random.normal(0, 1, 1000).reshape((1000, 1)) # conditional average baseline response is -Z Y1 = Z + np.random.normal(0, 1, 1000).reshape((1000, 1)) # conditional average treatment effect is +Z D = (np.random.uniform(0, 1, n)&lt;.2).reshape((1000, 1)) # treatment indicator; only 20% get treated np.mean(D) ## 0.181 Y = Y1*D + Y0*(1-D) # observed Y D = D - mean(D) # demean D Z = Z-mean(Z) # demean Z   Y = Y1*D + Y0*(1-D) # observed Y D = D - np.mean(D) # demean D Z = Z - np.mean(Z) # demean Z "],["analyze-the-rct-data-with-precision-adjustment.html", "Chapter 6 Analyze the RCT data with Precision Adjustment", " Chapter 6 Analyze the RCT data with Precision Adjustment Consider classical 2-sample approach, no adjustment (CL) classical linear regression adjustment (CRA) interactive regression adjusment (IRA) Carry out inference using robust inference, using the sandwich formulas (Eicker-Huber-White). Observe that CRA delivers estimates that are less efficient than CL (pointed out by Freedman), whereas IRA delivers more efficient approach (pointed out by Lin). In order for CRA to be more efficient than CL, we need the CRA to be a correct model of the conditional expectation function of Y given D and X, which is not the case here. library(lmtest) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric CL = lm(Y ~ D) CRA = lm(Y ~ D+ Z) #classical IRA = lm(Y ~ D+ Z+ Z*D) #interactive approach # we are interested in the coefficients on variable &quot;D&quot;. library(sandwich) library(lmtest) coeftest(CL, vcov = vcovHC(CL, type=&quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.038457 0.042730 0.9000 0.3683 ## D 0.010373 0.109479 0.0947 0.9245 coeftest(CRA, vcov = vcovHC(CRA, type=&quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.038457 0.039038 0.9851 0.3248 ## D 0.070199 0.136195 0.5154 0.6064 ## Z -0.555628 0.050840 -10.9289 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 coeftest(IRA, vcov = vcovHC(IRA, type=&quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.007973 0.031466 0.2534 0.8000 ## D -0.054906 0.077519 -0.7083 0.4789 ## Z -0.568043 0.031620 -17.9647 &lt;2e-16 *** ## D:Z 1.869928 0.078191 23.9147 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1   Z_times_D = Z*D X = np.hstack((D, Z, Z_times_D)) data = pd.DataFrame(X, columns = [&quot;D&quot;, &quot;Z&quot;, &quot;Z_times_D&quot;]) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
